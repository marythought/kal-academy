# 21. Given a BST, create a linkedlist of all the nodes at each depth
#
# 22. Convert a BST into a doubly linkedlist.
#
# 23. Determine if a binary tree is balanced
#
# 24. Given a sorted array, create a binary search tree with minimal height
#
# 25. Implement a function to check if a binary tree is a BST
#
# 26. Write an algorithm to find the next node (i.e in-order successor) of a given node in a binary search tree. You may assume that each node has a link to its parent
#
# 27. Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a data structure. NOTE: This is not necessarily a BST
#
# 28. You have 2 very large binary trees: T1 with millions of nodes, and T2 with hundreds of nodes. Create an algorithm to decide if T2 is a subtree of T1. A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the two trees would be identical.
#
# 29. You are given a binary tree in which each node contains a value. Design an algorithm to print all paths which sum to a given value. Note that a path can start or end anywhere in the tree.
